---
title:  "[자바] Ch3. 연산자"
excerpt: "연산자 우선순위와 각 연산자에 대해 자세한 설명"
date:   2023-03-07
last_modified_at: 2023-03-07
categories:
  - Java
toc: true
toc_sticky: true
---
<span style="font-size: 0.7em">`📑 <Java의 정석 - 지은이: 남궁 성>을 공부하며 정리한 내용입니다.`</span>

## 1. 연산자(operator)
---
연산자: +, -, *, / 등 기호  
피연산자(operand): 연산의 대상. 변수, 상수, 리터럴 등  

### 연산자 종류
---
산술 연산자: +, -, *, /, %, <<, >>  
비교 연산자: <, >, >=, <=, ==, !=  
논리 연산자: &&, ||, !, &, |, ^, ~  
대입 연산자: =  
기타 연산자: 형변환(), 삼항?:, instanceof
<br>
** 나머지 연산자는 피연산자로 정수만 허용.
** instanceof 연산자는 객체의 타입을 확인할 때 사용된다.
<br>

### 연산자 우선순위
---
```
                            <우선순위>
단항                           높음

산술  * / %                     |
      + -
     << >>

비교 < > <= >= instanceof       |
     == !=

논리 &                          |
     ^  
     |
     &&                         |  
     ||
                             
삼항                            
대입                           낮음
```  
** 삼항 연산자의 결합규칙(방향)은 '<-' 이다.  
<br>

### 산술 변환
---
연산 전에 피연산자 타입의 일치를 위해 <u>자동 형변환</u> 되는 것을 '산술 연산' 또는 '일반 산술 변환'이라 한다.  
  

두 피연산자의 타입이 서로 다른데 연산을 해야 한다면, 둘 중 더 큰 타입으로 일치시켜야 한다.  
이때, 자동으로 형변환이 된다.  
<br>
만약 작은 타입으로 일치시킨다면, 값 손실이 생길 수 있기 때문에 오류 메세지가 뜰 것이다.  
** int보다 작은 타입끼리의 연산은 자동으로 int로 변환됨.  
&nbsp;&nbsp;char나 short, byte는 연산 중 오버플로우 발생 가능성 높기 때문

<br>
<br>

## 2. 단항 연산자
---
증감 연산자가 수식이나 메서드 호출에 포함된 경우  

- 전위형(prefix)  
  값이 참조되기 전 값 증감
<br>

- 후위형(postfix)  
  값이 참조된 후 증감
<br>

ex)  
```java
int x = 9;
int y = x++ - ++x;
System.out.println(x); //11 출력.
System.out.println(y); //-2 출력. y = 9 - 11


int x = 9;
int y = x++ + x++;
System.out.println(x); //11 출력.
System.out.println(y); //19 출력. y = 9 + 10
```  
이것을 이해하려면 ++이 어떻게 구현되어 있는가를 봐야 한다.  

밑 정의를 보면 쉽게 이해할 수 있다.  
```c
int postfix(int *num){ //x++
    int tmp;
    tmp = *num;
    *num = temp + 1; //x의 값은 바뀌었지만
    return tmp;      //원래 값을 리턴한다.
}
```  
```c
int prefix(int *num){ //++x
    *num += 1;    //x의 값이 바뀌고
    return *num;  //x를 출력한다.
}
```
<br>
<br>

## 3. 산술 연산자
---
```java
char a = 'a';
char b1 = a + 1; //컴파일 에러. (char)(a + 1) 형변환 필요.
char b2 = 'a' + 1; //ok.
```
b1은 안 되고, b2는 되는 이유는,,  
<br>
b1은 형변환을 해주지 않으면, (a + 1) 연산 시 자동으로 int형이 되기 때문이다.  
b2에서 'a'와 1은 리터럴 값이고 실행하는 동안 값이 바뀌지 않기 때문에,  
컴파일러가 컴파일 시 미리 값을 계산하여 대체하기 때문이다.  
<br>
<br>

## 비교 연산자
---
대소비교 연산자: boolean형, 참조형은 사용X  
등가비교 연산자: 모든 자료형 O
<br>

ex)  
```java
System.out.printf("%b%n", 10.0 == 10.0f); //true 출력. 10.0 == 10f 도 마찬가지.
System.out.printf("%b%n", 10 == 10.0f); //true 출력. 10 == 10f 도 마찬가지.

System.out.printf("%b%n", 0.1 == 0.1f); //false 출력.
```  
왜 10.0 == 10.0f는 true인데, 0.1 == 0.1f는 false일까?  
<br>
먼저 float과 double 중 double 타입이 더 크므로 double로 자동 형변환된다.  
float을 double로 형변환하면 부호와 지수는 그대로, 가수의 빈자리를 0으로 채운다.  
(실수형은 근사값으로 저장된다.)  
<br>
10.0f는 double로 형변환 시 오차가 없지만, 0.1f는 double로 형변환 시 오차가 발생한다.  

```java
float f = 0.1f; // 0.10000000149011612로 저장됨
double d = 0.1; // 0.10000000000000001로 저장됨
```

### 문자열 비교
---
equals() 사용  
대소문자 구별없이 비교: equalsIgnoreCase()
```java
String str = new String("abc");
boolean b = str.equals("abc"); //그냥 == 으로 비교하면, 내용이 아니라 두 객체가 같은 건지 다른 건지 판별
```  
<br>
** 문자열 설명
 => <https://dms5o.github.io/java/javaCh9/>  
<br>
<br>

## 4. 논리 연산자
---
&&, ||는 효율적인 연산을 한다.  
즉 앞에 있는 피연산자로 결과를 확정할 수 있으면, 뒤 피연산자는 보지 않고 결과를 낸다.  
=> <span style="background-color:#fff5b1">||의 경우 '참'일 확률이 높은 피연산자 먼저, &&의 경우 '거짓'일 확률이 높은 피연산자 먼저 두면 연산 속도 up</span>  
=> 뒤에 연산이 붙어 있는 경우 수행되지 않을 수 있으므로 주의해야 한다.  
<br>

### 비트 연산자
---
** 피연산자로 실수X  
- | (or)  
  특정 비트 값 변경할 때  
<br>

- & (and)  
  특정 비트 값 뽑아낼 때  
<br>

- ^ (xor)  
  간단한 암호화에 사용된다.  
<br>

- ~ (비트 전환)  
  1의 보수 값을 얻을 수 있다.  
<br>

- &lt;&lt; (왼쪽)  
  빈칸을 0으로 채운다.  
  x << n은 x * 2 ^ n 과 같다.  
  결과는 int 타입
<br>

- &gt;&gt; (오른쪽)  
  음수인 경우 1, 양수일 때는 0으로 채운다.  
  x >> n은 x / 2 ^ n 과 같다.  
  결과는 피연산자 타입  
<br>
** << >> 이 * / 와 같은 결과를 내지만 더 빠르다.  
&nbsp;&nbsp;but 가독성이 떨어지므로 지양하자.  
<br>

<br>
<br>











