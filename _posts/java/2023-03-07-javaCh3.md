---
title:  "[자바] Ch3. 연산자"
excerpt: ""
date:   2023-03-07
last_modified_at: 2023-03-07
categories:
  - Java
toc: true
toc_sticky: true
---
<span style="font-size: 0.7em">`📑 <Java의 정석 - 지은이: 남궁 성>을 공부하며 정리한 내용입니다.`</span>

## 1. 연산자(operator)
---
연산자: +, -, *, / 등 기호  
피연산자(operand): 연산의 대상. 변수, 상수, 리터럴 등  

### 연산자 종류
---
산술 연산자: +, -, *, /, %, <<, >>  
비교 연산자: <, >, >=, <=, ==, !=  
논리 연산자: &&, ||, !, &, |, ^, ~  
대입 연산자: =  
기타 연산자: 형변환(), 삼항?:, instanceof
<br>
** 나머지 연산자는 피연산자로 정수만 허용.
** instanceof 연산자는 객체의 타입을 확인할 때 사용된다.
<br>

### 연산자 우선순위
---
```
                            <우선순위>
단항                           높음

산술  * / %                     |
      + -
     << >>

비교 < > <= >= instanceof       |
     == !=

논리 &                          |
     ^
     |
     &&                         |  
     ||
                             
삼항                            
대입                           낮음
```  
** 삼항 연산자의 결합규칙(방향)은 '<-' 이다.  
<br>

### 산술 변환
---
연산 전에 피연산자 타입의 일치를 위해 <u>자동 형변환</u> 되는 것을 '산술 연산' 또는 '일반 산술 변환'이라 한다.  
  

두 피연산자의 타입이 서로 다른데 연산을 해야 한다면, 둘 중 더 큰 타입으로 일치시켜야 한다.  
이때, 자동으로 형변환이 된다.  
만약 작은 타입으로 일치시킨다면, 값 손실이 생길 수 있기 때문에 오류 메세지가 뜰 것이다.  
** int보다 작은 타입끼리의 연산은 자동으로 int로 변환됨.  
&nbsp;&nbsp;char나 short, byte는 연산 중 오버플로우 발생 가능성 높기 때문

<br>
<br>

## 단항 연산자
---
증감 연산자가 수식이나 메서드 호출에 포함된 경우  

- 전위형(prefix)
  값이 참조되기 전 값 증감
<br>

- 후위형(postfix)
  값이 참조된 후 증감
<br>

ex)
```java
int x = 9;
int y = x++ - ++x;
System.out.println(x); //11 출력.
System.out.println(y); //-2 출력. y = 9 - 11


int x = 9;
int y = x++ + x++;
System.out.println(x); //11 출력.
System.out.println(y); //19 출력. y = 9 + 10
```
이것을 이해하려면 ++이 어떻게 구현되어 있는가를 봐야 한다.  

밑 정의를 보면 쉽게 이해할 수 있다.  
```c
int postfix(int *num){ //x++
    int tmp;
    tmp = *num;
    *num = temp + 1; //x의 값은 바뀌었지만
    return tmp;      //원래 값을 리턴한다.
}
```  
```c
int prefix(int *num){ //++x
    *num += 1;    //x의 값이 바뀌고
    return *num;  //x를 출력한다.
}
```
<br>
<br>

## 산술 연산자
---
```java
char a = 'a';
char b1 = a + 1; //컴파일 에러. (char)(a + 1) 형변환 필요.
char b2 = 'a' + 1; //ok.
```
b1은 안 되고, b2는 되는 이유는,,  
b1은 형변환을 해주지 않으면, (a + 1) 연산 시 자동으로 int형이 되기 때문이다.  
b2에서 'a'와 1은 리터럴 값이고 실행하는 동안 값이 바뀌지 않기 때문에,  
컴파일러가 컴파일 시 미리 값을 계산하여 대체하기 때문이다.  
<br>
<br>

## 비교 연산자
---





